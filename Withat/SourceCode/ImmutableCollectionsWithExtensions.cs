namespace Withat.SourceCode;

internal static class ImmutableCollectionsWithExtensions
{
    
    public static string GenerateSourceCode()
    {
        return DictExtensionsSourceCode
               + GenerateListExtensions("ImmutableArray", "Length")
               + GenerateListExtensions("ImmutableList", "Count")
               + GenerateListExtensions("IImmutableList", "Count")
               + "}";
    } 
    
    
    
    private const string DictExtensionsSourceCode = @"
// <auto-generated/>
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Linq;
namespace Withat;
internal static class ImmutableCollectionsWithExtensions
{
    public static ImmutableDictionary<TKey, TValue> With<TKey, TValue>(
        this ImmutableDictionary<TKey, TValue> dictionary, 
        TKey key, 
        Func<TValue, TValue> valueFunc,
        [CallerArgumentExpression(nameof(dictionary))] string dictName = """"
    )

    {
        if (!dictionary.TryGetValue(key, out var existing))
        {
            throw new KeyNotFoundException($""No value for key '{key}' in '{dictName}'!"");
        }

        return dictionary.SetItem(key, valueFunc(existing));
    }
    
    
    public static IImmutableDictionary<TKey, TValue> With<TKey, TValue>(
        this IImmutableDictionary<TKey, TValue> dictionary, 
        TKey key, 
        Func<TValue, TValue> valueFunc,
        [CallerArgumentExpression(nameof(dictionary))] string dictName = """"
    )

    {
        if (!dictionary.TryGetValue(key, out var existing))
        {
            throw new KeyNotFoundException($""No value for key '{key}' in '{dictName}'!"");
        }

        return dictionary.SetItem(key, valueFunc(existing));
    }

    public static async Task<ImmutableDictionary<TKey, TValue>> With<TKey, TValue>(
        this ImmutableDictionary<TKey, TValue> dictionary, 
        TKey key, 
        Func<TValue, Task<TValue>> valueFuncTask,
        [CallerArgumentExpression(nameof(dictionary))] string dictName = """"
    )

    {
        if (!dictionary.TryGetValue(key, out var existing))
        {
            throw new KeyNotFoundException($""No value for key '{key}' in '{dictName}'!"");
        }

        return dictionary.SetItem(key, await valueFuncTask(existing));
    }
    
    
    public static async Task<IImmutableDictionary<TKey, TValue>> With<TKey, TValue>(
        this IImmutableDictionary<TKey, TValue> dictionary, 
        TKey key, 
        Func<TValue, Task<TValue>> valueFuncTask,
        [CallerArgumentExpression(nameof(dictionary))] string dictName = """"
    )

    {
        if (!dictionary.TryGetValue(key, out var existing))
        {
            throw new KeyNotFoundException($""No value for key '{key}' in '{dictName}'!"");
        }

        return dictionary.SetItem(key, await valueFuncTask(existing));
    }
";
    
    
    
    
    
    
    private static string GenerateListExtensions(string collectionType, string countProperty)
        {
            var s_tmp = $@"
    public static {collectionType}<TValue> With<TValue>(
        this {collectionType}<TValue> array, 
        int index, 
        Func<TValue, TValue> valueFunc, 
        [CallerArgumentExpression(nameof(array))] string arrayName = """"
    )
    {{
        if (index >= array.{countProperty})
        {{
            throw new IndexOutOfRangeException($""The index {{index}} is greater than the length of '{{arrayName}}' ({{arrayName}}.length is {{array.{countProperty}}})!"");
        }}

        return array.SetItem(index, valueFunc(array[index]));
    }}

    public static {collectionType}<TValue> WithFirst<TValue>(
        this {collectionType}<TValue> array, 
        Func<TValue, bool> filter, 
        Func<TValue, TValue> valueFunc, 
        [CallerArgumentExpression(nameof(array))] string arrayName = """", 
        [CallerArgumentExpression(nameof(filter))] string filterName = """"
    )
    {{
        for (int i = 0; i < array.{countProperty}; i++)
        {{
            if (filter(array[i]))
            {{
                return array.SetItem(i, valueFunc(array[i]));
            }}
        }}
        throw new InvalidOperationException($""No item for filter '{{filterName}}' found in '{{arrayName}}'!"");
    }}

    public static {collectionType}<TValue> WithFirstOrDefault<TValue>(
        this {collectionType}<TValue> array, 
        Func<TValue, bool> filter, 
        Func<TValue, TValue> valueFunc
    )
    {{
        for (int i = 0; i < array.{countProperty}; i++)
        {{
            if (filter(array[i]))
            {{
                return array.SetItem(i, valueFunc(array[i]));
            }}
        }}

        return array;
    }}

    public static {collectionType}<TValue> WithAll<TValue>(
        this {collectionType}<TValue> array, 
        Func<TValue, bool> filter, 
        Func<TValue, TValue> valueFunc
    )

    {{
        var result = new Lazy<TValue[]>(()=>array.ToArray());
        for (int i = 0; i < array.{countProperty}; i++)
        {{
            if (filter(array[i]))
            {{
                result.Value[i] = valueFunc(array[i]);
            }}
        }}

        return result.IsValueCreated ? [..result.Value] : array;
    }}
";
            return s_tmp + s_tmp
                             .Replace($"public static {collectionType}<TValue>",
                                 $"public static async Task<{collectionType}<TValue>>")
                             .Replace("Func<TValue, TValue> valueFunc", "Func<TValue, Task<TValue>> valueFuncTask")
                             .Replace("valueFunc(array", "await valueFuncTask(array");

        }
}